* Preparation

Read all the documentation provided by the author of the lab.

Install =flex= and =bison= on your computer. They are required to build
the various tools used by the lab.

Edit =misc/Makefile= and =pipe/Makefile=. Make sure that the compiler
flags include =-fcommon=.

#+begin_src diff
  modified   arch/archlab-handout/sim/misc/Makefile
  @@ -1,6 +1,6 @@
   CC=gcc
  -CFLAGS=-Wall -O1 -g
  -LCFLAGS=-O1
  +CFLAGS=-Wall -O1 -g -fcommon
  +LCFLAGS=-O1 -fcommon
   LEX = flex
   YACC=bison
   LEXLIB = -lfl
  modified   arch/archlab-handout/sim/pipe/Makefile
  @@ -23,7 +23,7 @@ TKINC=-isystem /usr/include/tcl8.5
   # flags.

   CC=gcc
  -CFLAGS=-Wall -O2
  +CFLAGS=-Wall -O2 -fcommon

   ##################################################
   # You shouldn't need to modify anything below here
#+end_src

* Part A

This part requires you to implement three functions using Y86-64
ISA. You can put your implementation in directory =y86-code=. Then, you
can compile =src.ys= by typing =make src.yo= in the =y86-code= directory. To
simulate your program, type =../misc/yis src.yo= in =y86-code= directory.

* Part B

| Stage      | iaddq V, rB                   |
| Fetch      | icode : ifun <- M_1[PC]        |
|            | rA : rB <- M_1[PC+1]           |
|            | valC <- M_8[PC+2]              |
|            | valP <- PC+10                 |
| Decode     | valA <- valC, valB <- R[rB]   |
| Execute    | valE <- valB add valA; set CC |
| Memory     |                               |
| Write back | R[rB] <- valE                 |
| PC update  | PC <- valP                    |

* Part C

The following command should be executed in the =pipe= directory.

Test =ncopy.ys=:

#+begin_src shell
  # Check length
  make ncopy.yo
  ./check-len.pl < ncopy.yo
  # Correctness
  make VERSION=full
  ./psim -t sdriver.yo
  ./psim -t ldriver.yo
  ../misc/yis sdriver.yo
  ./correctness.pl
#+end_src

Test simulator:

#+begin_src shell
  (cd ../y86-code; make testpsim)
  # if no iaadq implementation, remove TFLAGS
  (cd ../ptest; make SIM=../pipe/psim TFLAGS=-i)
  ./correctness.pl -p
#+end_src

Benchmark:

#+begin_src shell
  ./benchmark.pl
#+end_src

** Record

Initial average: 15.18

First attempt: only modified the source code, using =cmov= to compute
=count=, removed some redundant instructions. Average: 13.41.

Second attempt: adjust the order of some instructions to reduce data
dependencies between instructions. Average: 12.41.

*** DONE Implement IADDQ

*** DONE Implement BTFNT Branch Prediction

Implement this actually does not help much, because currently most
predication is correct.

*** DONE Loop Unrolling

Unroll the loop 8x1 times does not improve much.

** Implement Load Forwarding

To eliminate the stall introduced between the two instructions:

#+begin_example
        mrmovq 96(%rdi), %r10     # read val from src...
        rmmovq %r10, 96(%rsi)     # ...and store it to dst
#+end_example

We have to complete homework problems 4.57.

I have found a [[https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.57/][solution]], but I feel it is difficult to understand.

My own solution is different and I think it is more accurate than the
above one.

First, the condition of a LOAD/USE hazard when there is load
forwarding implemented. The essence of the LOAD/USE hazard with load
forwarding enabled is:

The value of the destination register of instruction =mrmovq= or =popq= is
used in the execute stage of the next instruction. Analyzing each
Y86-64 instruction one by one, one can find out that the following
instructions might use the value of an register in its execute stage:

+ =opq=: both the source and destination operand
+ =rrmovq=: only the source operand
+ =rmmovq=: only the destination operand, it is =RB= in Y86-64
+ =mrmovq=: only the source operand, it is =RB= in Y86-64
+ =ret=: when =mrmovq= or =popq= writes to =%rsp=
+ =iaddq=: only the destination operand

The condition of a LOAD/USE hazard can be obtained from the above
list.

To forward the value read from memory in a =mrmovq= or =popq= instruction:

#+begin_example
word e_valA = [
        E_icode in { IRMMOVQ, IPUSHQ } && E_srcA == M_dstM : m_valM;
	1 : E_valA;  # Use valA from stage pipe register
];
#+end_example
